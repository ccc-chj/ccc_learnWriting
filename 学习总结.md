2020-09-23中国有赞挂掉，感想难过，所以写一份个人总结。

Event.preventDefault().
	Event为dom事件，产生事件之后可以直接调用方法来阻止原生浏览器中事件默认产生的影响。

Ie盒子模型：
	两种盒子模型，一种为标准盒子，其长度只与自身content长度有关。另一种为怪异盒子模型，其长度计算为border+padding+content。通过设置box-sizing:content-box/border-box。
	Js获取box宽高：dom.style.width。带单位。

在ie下使用obj.currentStyle[name]，其他使用getComputedStyle(obj)[name];
    兼容：
    Function getCss(dom, name) {
        If(obj.currentStyle) {
            Return obj.currentStyle[name]
        } else {
            Return getComputeStyle(obj)[name];
        }
    }

    可惜的是上面两个只能获取css属性，而不能获取元素自身的宽高。
    offsetWidth: 获取元素实际大小，返回的是一个不带单位的值。
    clientWidth: 可视区域的大小。

margin:
    1、子孙级元素如果不清除浮动时，那么在子级元素设置margin-top时会穿透父级。
    解决方案:
            1、父级设置边框
            2、升级bfc
            3、不使用margin-top
    2、同一个bfc时，发生边距重叠。
    解决方案：
            1、设置不同的bfc。
            2、用其他盒子包裹起来。

定位：
    1、普通流：元素从上到下一次排列，块级元素独自沾满一行，内联元素不分行，占满则换行。
    2、浮动流：元素先按照普通流排列，然后计算时尽可能按照浮动方向左移或者右移。
    3、绝对定位：脱离文档流，不影响其他节点。（absolute和fixed统称为绝对定位）
        1) 相对定位：相对原来位置移动，但是原位置保留，并不脱离原文档流。

bfc：block formatting context,格式化上下文，独立的布局环境，其元素不受外界影响。
    1、触发：
        1) 浮动元素：除float：none;以外的任何形式。
        2) 绝对定位元素
        3) display: inline-block、table-cells、flex
        4) overflow除了visible以外的值， hidden, auto, scroll。
    2、属性及应用
        1) 同级bfc下应用会发生边距合并。
        2) bfc会包含浮动元素(可以用来清楚浮动的影响)

xss: 跨站脚本攻击(cors site script)
    1、原理：攻击者利用开发者的漏洞（没有对用户的输入进行转义），进而添加一些代码，嵌入到web中，从而使别的用户访问时会执行相应的代码。
    2、危害：
        1) 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
        2) 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
        3) 盗窃企业重要的具有商业价值的资料
        4) 非法转账
        5) 强制发送电子邮件
        6) 网站挂马
        7) 控制受害者机器向其它网站发起攻击
    3、原因分析：过于信任客户输出。
    4、形式分析
        1) 反射型：放在地址栏里。
        2) 存储型：纯进数据库中。
        3) DOMBasedXSS: 通过dom

csrf：跨站请求伪造。
    1.登录受信任网站A，并在本地生成Cookie。
    2.在不登出A的情况下，访问危险网站B。
　　看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：
    　　1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。
    　　2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了......）
    　　3.所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。
    3、客户端随机数验证。

cokkie：用于验证和注册http请求状态。
    1、保存在客户端。
    2、字段：
        1、http-only：客户端不能使用脚本访问cokkie。
        2、domain：允许访问此cokkie的域名。
        3、path：可以访问此cokkie的路径。
        4、expires：过期时间。
        5、secure：只能用https访问。

树的访问：
    1、递归：
        1、递归整棵树：
            1、前序遍历：根节点-左子树-右子树。
            2、中序遍历：左子树-根节点-右子树。
            后序遍历：左子树-右子树-根节点。
        2、访问深度：
            1、二叉树：
                function count(root) {
                    if (root == null)
                        return 0;
                    return Math.max(count(root.left), count(root.right)) +
                }
            2、n叉树
                function count(root) {
                    if (root.children == null)
                        return 0;
                    let max = 0;
                    root.children.forEach(item => {
                        max = Math.max(count(item), max);
                    })
                    return max + 1;
                }
    2、迭代思路：
        借助栈实现，比如实现先序遍历时，先将根节点入栈，然后循环，根节点左子树进栈，然后继续左子树，当左子树访问完成时，进入右子树。

translation和animation:
    translation：基于css的变化
        例子 translation:属性名 1s（动画时长）2s（动画延迟）ease（动画速率）
        多个属性动画相同可以all  2s  2s  ease；
        如果动画的属性不同可以用逗号 width 1s 2s ease，height 4s 2s ease；
    animation：基于动画

函数柯里化：
    代码见目录。

vue：
    1、diff与patch
        1、O(n3) -> O(n)?
            答：由于现在算法只需要在树的同级比较，所以只需要O(n)。也就是同级别比较算法。简单形式处理为：直接将同级别的原节点删除，直接添加新节点。
        2、vue的几种diff方式（渲染器的核心）：比对会层级的比对，如：先比对是否是组件，然后是标签名，然后是数据。
            1、同级别比较，算法如上。但是由于这种方式消耗过大，因为无法复用以前的节点，所以我们应该尽可能的去复用以前的节点。
                1、第一种方式是去比对旧节点数组，children，如果发现新节点里有此节点，则不删除。但是如果旧的节点数组要比新的节点数组要多时，那么就会产生很多额外的代价，所以这方式也并不可取。
                2、我们应该每次去比对新的数组节点，因为这中方式比对时，新节点数组patch完成之后，如果旧节点数组里没有我想要拿到的节点，则直接删除，然后将剩余的新节点直接放上去。
                3、复用原则：
                    因为我们需要尽可能的将旧节点复用，但是每次去拿取旧节点时都是非常费力的，所以我们希望给加一个key值，这样能够在比对是非常方便的获取到节点。
            2、双端比较：
                四个索引，同时从前后开始比对。每次都头尾相互比较。
    2、生命周期：
        1、组件主生命周期：
            从beforeCreate -> create -> beforeMounted -> mounted -> beforeUpdate -> update -> beforeDestroy -> destroy.
            理解：每次触发相关的钩子函数时，都会做相关的准备，带before的钩子时，你可以在这里做一些你想要的，或是需要提前执行完成的（主线任务，注意这里不要写异步任务，虽然写异步任务本身并没有什么关系，但是没有意义，因为如果是异步任务的话，写在哪里都一样）任务，然后在对应的钩子函数里完成相关事务。事务所对应的是：
                create: 组件属性和变量的准备。
                mount: 页面节点的构建与挂载。
                update: 页面渲染涉及到的依赖发生改变被通知更新。（这里涉及到另一个点vue.$nexttick）
                    定义更新使用updateComponent方法，内部调用vue初始化的_update私有方法
                destroy: 页面销毁

        2、父子组件生命周期：
            由于组件的生命周期如上，但是如果在组件里面嵌套了一个子组件时，那么子组件的生命周期变化：
                1、父组件执行到beforeMount时，需要去查找页面所引入的依赖，此时如果查找到子组件时，那么需要重新去加载自组件的变量和属性，则此时进入到子组件的beforeCreated，然后再继续进行，直到子组件的beforeMount时，此时需要再去查找依赖。如果继续有子组件，则继续进入。没有就挂载，然后退出，退出到父组件的mount。那么前期完成。
                2、同理的，销毁和更新也是同样的。
                3、顺提一句就是携带动态路由的组件在渲染时，他的部分生命周期会失效，因为vue在对动态路由做处理时，并不会销毁掉，而是缓存起来继续使用，所以不会触发部分生命周期。

    3、vue实例化过程：
        1、实例化属性合并：
            extends和mixins属性合并。
        2、初始化组件生命周期标志。
        3、初始化事件系统。
        4、初始化组件render系统。
        5、初始化组件注册依赖。
        6、初始化data，props，methods，watch，computed。
            initProps:将父组件的传递的值响应式处理。
            initMethods：事件注册。
            initData：将data里的属性响应式处理
                获取data属性，将属性挂载到当前vm实例上
                添加发布订阅模型中
                响应式处理defineReactive
                get/set 用于派发
                遍历属性时做如下处理：
                    遍历对象时，深入递归对象，将处理过的属性加上_ob_属性。
                    遍历数组时，挟持数组的7种数据更替方式
        7、initProvide。
        8、编辑模板加载。
            获取template模板 -> 编译成ast(抽象语法树) -> 解析render函数，字符串形式 -> 生产render函数，挂载到options中，render唯一 -> 挂载dom
            然后又是最初的patch/diff。
            render函数其实是返回的一个vnode

    4、vuex：vuex是一个应用于vue而生的状态管理工具，其目的就是为了让vue的所有的状态共享，且可追踪，由于前端js本身就必须处理一些异步的逻辑，而异步又无法追踪，于是便有了action，为异步而生。

    5、nexttick:
        1、nexttick的作用就是可以让视图的变化更新不会太频繁，当我们的依赖发生了改变时，将他收集起来，而当达到一个度了之后再将他批量次的更新。
        2、nexttick的设计是异步的，其道理等同于react的setState。
            这里和浏览器的渲染有关系：因为浏览器的每次更新需要与js的线程互斥，所以浏览器的渲染是有时机的。时机就是每次事件循环的完成（首次渲染是在第一次事件循环完成）。
    
webpack：
    打包过程：
        

    
        
            
                

